// utils.test.ts

import { processNode, loop, make } from './utils';  // Adjust the import path

describe('Testing processNode function', () => {
  it('should return correct path and parents for a valid node', () => {
    const parents: any[] = [];
    const path: any[] = [];
    const node = { key1: 'value1', key2: 'value2' };
    const result = processNode(parents, path, node);
    expect(result).toHaveProperty('path');
    expect(result).toHaveProperty('parents');
  });

  it('should return an empty path if the node is undefined', () => {
    const result = processNode([], [], undefined);
    expect(result.path).toEqual([]);
    expect(result.parents).toEqual([]);
  });
});

describe('Testing loop function', () => {
  it('should process a node correctly', () => {
    const node = { key1: 'value1', key2: 'value2' };
    const result = loop([node], []);
    expect(result.path).toBeDefined();
    expect(result.parents).toBeDefined();
  });

  it('should handle undefined node', () => {
    const result = loop([], []);
    expect(result.path).toEqual([]);
    expect(result.parents).toEqual([]);
  });
});

describe('Testing make function', () => {
  it('should return the node as-is when keys are empty', () => {
    const node = { key1: 'value1' };
    const result = make(node);
    expect(result).toEqual(node);
  });

  it('should use keys from utils if not provided', () => {
    const node = { key1: 'value1', key2: 'value2' };
    const result = make(node);
    expect(result).toBeDefined();
  });
});
